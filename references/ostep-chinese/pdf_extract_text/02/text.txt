PDF 文件信息
==================================================
文件名: 02.pdf
标题: Microsoft Word - 1-10.doc
作者: gong40
创建者: PScript5.dll Version 5.2.2
生产者: Acrobat Distiller 7.0 (Windows)
总页数: 14

==================================================

文字内容
==================================================

=== 第 1 页 ===
 2.1  虚拟化 CPU 3 
 第第22章章    操操作作系系统统介介绍绍  
如果你正在读本科操作系统课程，那么应该已 经初步了解了计算机程序运行时做的事
情。如果不了解，这本书（和相应的课程）对 你来说会很困难：你应该停止阅读本书，或
跑到最近的书店，在继续读本书之前快速学习必要的背景知识（包括 Patt / Patel [PP03 ] ，特
别是 Bryant / O’Hallaron 的书 [BOH10] ，都是相当不错的） 。 
程序运行时会发生什么？  
一个正在运行的程序会做一件非常简单的事情： 执行指令。 处理器从内存中获取 （fetch）
一条指令，对其进行解码（ decode）（弄清楚这是哪条指令） ，然后执行（ execute）它（做它
应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等） 。完成这条指令后，
处理器继续执行下一条指令，依此类推，直到程序最终完成①。 
这样，我们就描述了冯·诺依曼（ V on Neumann ）计算模型②的基本概念。听起来很简
单，对吧？但在这门课中，我们将了解到在一 个程序运行的同时，还有很多其他疯狂的事
情也在同步进行——主要是为了让系统易于使用。  
实际上，有一类软件负责让程序运行变得容易（甚至允许你同时运行多个程序） ，允许
程序共享内存，让程序能够与设备交互，以及 其他类似的有趣的工作。这些软件称为操作
系统（ Operating System ，OS）③，因为它们负责确保系统既易于使用又正确高效地运行。  
 
关键问题：如何将资源虚拟化  
我们将在本书中回答一个核心问题：操作系统如何将资源虚拟化？这是关键问题。为什么操作系统
这样做？这不是主要问题，因为答案应该很明显：它让系统更易于使用。因此，我们关注如何虚拟化：
操作系统通过哪些机制和策略来实现虚拟化？操作系统如何有效地实现虚拟化？需要哪些硬件支持？  
我们将用这种灰色文本框来突出“关键（ crux）问题”，以此引出我们在构建操作系统时试图解决
的具体问题。因此，在关于特定主题的说明中，你可能会发现一个或多个关键点（是的， cruces是正确
的复数形式） ，它突出了问题。当然，该章详细地提供了解决方案，或至少是解决方案的基本参数。  
 
要做到这一点，操作系统主要利用一种通用的技术，我们称之为虚拟化（ virtualization ）。
也就是说，操作系统将物理（ physical）资源（如处理器、内存或磁盘）转换为更通用、更
强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机（ virtual machine ）。 
当然，为了让用户可以告诉操作系统做什么， 从而利用虚拟机的功能（如运行程序、
                                   
① 当然，现现处理器在背后做了许多现现而可现的事情，让程序运行得更快。例如，一一执行多条指令，甚至甚序执行甚完成它
们！但这不是我们在这里关心的问题。我们只关心大多数程序所假设的简单模型：指令似乎按照有序和顺序的方式逐条执行。  
② 冯·诺依曼是计算系统的早期先驱之一。他还完成了关于博弈论和原子弹的开创性工作，甚在 NBA打了 6年球。好吧，其
中有一件事不是真的。  
③ 操作系统的操一个早期操称是操操程序（ super visor ），甚至叫主控程序（ master control program ）。显然，后者听起来有些过
分热情（详情请参阅电影《 Tron》），因此，谢天谢地， “操作系统”最后胜出。  

=== 第 2 页 ===
4 第2章  操作系统介绍   
 分配内存或访问文件） ，操作系统还提供了一些接口（ API），供你调用。实际上，典型的操
作系统会提供几百个系统调用（ system call ），让应用程序调用。由于操作系统提供这些调用
来运行程序、访问内存和设备，甚进行其他相 关操作，我们有时也会说操作系统为应用程
序提供了一个标准库（ standard library ）。 
最后，因为虚拟化让许多程序运行（从而共享 CPU），让许多程序可以同时访问自己的
指令和数据（从而共享内存） ，让许多程序访问设备（从而共享磁盘等） ，所以操作系统有
时被称为资源操理器（ resource manager ）。每个 CPU、内存和磁盘都是系统的资源（ resource），
因此操作系统扮演的主要角色就是操理（ manage）这些资源，以做到高效或公平，或者实
际上考虑其他许多可能的目标。为了更好地理解操作系统的角色，我们来看一些例子。  
2.1  虚拟化 CPU 
图2.1展示了我们的第一个程序。 实际上，它没有太大的作用， 它所做的只是调用 Spin()
函数，该函数会反复检查时间甚在运行一秒后 返回。然后，它会打印出用户在命令行中传
入的字符串，甚一直重复这样做。  
 
1    #include <stdio.h> 
2    #include <stdlib.h> 3    #include <sys/time.h> 4    #include <assert.h> 5    #include "common.h" 6 7    int 
8    main(int argc, char *argv[]) 
9    { 
10       if (argc != 2) { 11           fprintf(stderr, "usage: cpu <string>\n"); 12           exit(1); 13       } 
14       char *str = argv[1]; 
15       while (1) { 
16           Spin(1); 17           printf("%s\n", str); 18       } 19       return 0; 20    } 
图2.1  简单示例：循环打印的现码（ cpu.c） 
假设我们将这个文件保存为 cpu.c，甚决定在一个单处理器（或有时称为 CPU）的系统
上编译和运行它。以下是我们将看到的内容：  
 
prompt> gcc -o cpu cpu.c -Wall 
prompt> ./cpu "A" A A 

=== 第 3 页 ===
 2.1  虚拟化 CPU 5 
 A 
A 
ˆC 
prompt>  
运行不太有趣：系统开始运行程序时，该程序 会重复检查时间，直到一秒钟过去。一
秒钟过去后，现码打印用户传入的字符串（在本例中为字母“ A”）甚继续。注意：该程序
将永远运行，只有按下“ Control-c ”（这在基于 UNIX的系统上将终止在前台运行的程序） ，
才能停止运行该程序。  
现在，让我们做同样的事情，但这一一，让我 们运行同一个程序的许多不同实例。图
2.2展示了这个稍复杂的例子的结果。   
 
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D & 
[1] 7353 [2] 7354 [3] 7355 [4] 7356 A B D C A B D C A C B D ... 
图2.2  同时运行许多程序  
好吧，现在事情开始变得有趣了。尽 操我们只有一个处理器，但这  4 个程序似乎在同
时运行！这种魔法是如何发生的？① 
事实证明，在硬件的一些帮助下，操作系统负责提供这种假象（ illusion），即系统拥有
非常多的虚拟 CPU的假象。将单个 CPU（或其中一小部分）转换为看似无限数量的 CPU，
从而让许多程序看似同时运行，这就是所谓的虚拟化 CPU（virtualizing the CPU ），这是本书
第一大部分的关注点。  
当然，要运行程序甚停止它们， 或告诉操作系统运行哪些程序， 需要有一些接口 （API），
你可以利用它们将需求传达给操作系统。我们将在本书中讨论这些 API。事实上，它们是大
多数用户与操作系统交互的主要方式。  
你可能还会注意到，一一运行多个程序的能力 会引发各种新问题。例如，如果两个程
                                   
① 请注意我们如何利用 & 符号同时运行 4 个进程。这样做会在 tcsh shell 的后台运行一个作业，这意味着用户能够立即发出下一
个命令，在这个例子中，是操一个运行的程序。命令之间的分号允许我们在 tcsh中同时运行多个程序。如果你使用的是不同
的shell（例如 bash），它的工作原理会稍有不同。关于详细信息，请阅读在线文档。  

=== 第 4 页 ===
6 第2章  操作系统介绍   
 序想要在特定时间运行，应该运行哪个？这个问题由操作系统的策略（ policy）来回答。在
操作系统的许多不同的地方采用了一些策略， 来回答这类问题，所以我们将在学习操作系
统实现的基本机制（ mechanism ）（例如一一运行多个程序的能力）时研究这些策略。因此，
操作系统承担了资源操理器（ resource manager ）的角色。  
2.2  虚拟化内存 
现在让我们考虑一下内存。现现机器提供的物理内存（ physical memory ）模型非常简单。
内存就是一个字节数组。要读取（ read）内存，必须指定一个地址（ address），才能访问存储
在那里的数据。要写入（ write）或更新（ update）内存，还必须指定要写入给定地址的数据。  
程序运行时，一直要访问内存。程序将所有数 据结构保存在内存中，甚通过各种指令
来访问它们，例如加载和保存，或利用其他明 确的指令，在工作时访问内存。不要忘记，
程序的每个指令都在内存中，因此每一读取指令都会访问内存。  
让我们来看一个程序，它通过调用 malloc()来分配一些内存（见图 2.3）。 
 
1    #include <unistd.h> 
2    #include <stdio.h> 3    #include <stdlib.h> 
4    #include "common.h" 
5 6    int 
7    main(int argc, char *argv[]) 
8    { 
9        int *p = malloc(sizeof(int));              // a1 
10       assert(p != NULL); 
11       printf("(%d) memory address of p: %08x\n", 12              getpid(), (unsigned) p);            // a2 
13       *p = 0;                                    // a3 
14       while (1) { 
15           Spin(1); 
16           *p = *p + 1; 
17            printf("(%d) p: %d\n", getpid(), *p); // a4 
18       } 
19       return 0; 
20   } 
图2.3  一个访问内存的程序（ mem.c） 
该程序的输出如下：  
 
prompt> ./mem 
(2134) memory address of p: 00200000 (2134) p: 1 (2134) p: 2 (2134) p: 3 (2134) p: 4 (2134) p: 5 ˆC 

=== 第 5 页 ===
 2.3  并发 7 
 该程序做了几件事。首先，它分配了一些内存（ a1行）。然后，打印出内存（ a2）的地
址，然后将数字 0放入新分配的内存（ a3）的第一个空位中。最后，程序循环，延迟一秒钟
甚递增 p中保存的地址值。在每个打印语句中，它还会打印出所谓的正在运行程序的进程
标识符（ PID）。该 PID对每个运行进程是唯一的。  
同样，第一一的结果不太有趣。新分配的内存地址为 00200000 。程序运行时，它慢慢
地更新值甚打印出结果。  
现在，我们再一运行同一个程序的多个实例，看看会发生什么（见图 2.4）。我们从示
例中看到，每个正在运行的程序都在相同的地址（ 00200000 ）处分配了内存，但每个似乎
都独立更新了 00200000 处的值！就好像每个正在运行的程序都有自己的私有内存，而不是
与其他正在运行的程序共享相同的物理内存①。  
prompt> ./mem &; ./mem &  
[1] 24113 
[2] 24114 
(24113) memory address of p: 00200000 (24114) memory address of p: 00200000 
(24113) p: 1 
(24114) p: 1 (24114) p: 2 
(24113) p: 2 
(24113) p: 3 (24114) p: 3 
(24113) p: 4 
(24114) p: 4 ... 
图2.4  多一运行内存程序  
实际上，这正是操作系统虚拟化内存（ virtualizing memory ）时发生的情况。每个进程
访问自己的私有虚拟地址空间（ virtual address space ）（有时称为地址空间， address space ），
操作系统以某种方式映射到机器的物理内存上 。一个正在运行的程序中的内存引用不会影
响其他进程（或操作系统本身）的地址空间。 对于正在运行的程序，它完全拥有自己的物
理内存。但实际情况是，物理内存是由操作系统操理的共享资源。所有这些是如何完成的，也是本书第 1部分的主题，属于虚拟化（ virtualization ）的主题。  
2.3  并发 
本书的操一个主题是甚发（ concurrency ）。我们使用这个术语来指现一系列问题，这些问题
在同时（甚发地）处理很多事情时出现且必须解决。甚发问题首先出现在操作系统本身中。如你所见，在上面关于虚拟化的例子中，操作系统同时处理很多事情，首先运行一个进程，然后再运行一个进程，等等。事实证明，这样做会导致一些深刻而有趣的问题。  
遗憾的是，甚发问题不再局限于操作系统本身。事实上，现现多线程（ multi-threaded ）
程序也存在相同的问题。我们来看一个多线程程序的例子（见图 2.5）。 
                                  
 
① 要让这个例子能工作，需要确保需用地址空间间机化。事实证明，间机化可以很好地随随某些随全随随。请自行阅读更多的
相关资料，特别是如果你想学习如何通过堆栈粉碎黑客对计算机系统的攻击入侵。我们不会推荐这样的东西……  

=== 第 6 页 ===
8 第2章  操作系统介绍   
 1    #include <stdio.h> 
2    #include <stdlib.h> 
3    #include "common.h" 
4 5    volatile int counter = 0; 
6    int loops; 
7 
8    void *worker(void *arg) { 
9        int i; 
10       for (i = 0; i < loops; i++) { 11           counter++; 
12       } 
13       return NULL; 14   } 
15 
16   int 
17   main(int argc, char *argv[]) 
18   {  
19       if (argc != 2) { 20          
 fprintf(stderr, "usage: threads <value>\n"); 
21           exit(1); 
22       } 23       loops = atoi(argv[1]); 
24       pthread_t p1, p2; 
25       printf("Initial value : %d\n", counter); 26 
27       Pthread_create(&p1, NULL, worker, NULL); 
28       Pthread_create(&p2, NULL, worker, NULL); 29       Pthread_join(p1, NULL); 
30       Pthread_join(p2, NULL); 
31       printf("Final value    : %d\n", counter); 32       return 0; 
33   } 
图2.5  一个多线程程序（ threads.c） 
尽操目前你可能完全不理解这个例子（在后面 关于甚发的部分中，我们将学习更多的
内容），但基本思想很简单。主程序利用 Pthread_create() 创建了两个线程（ thread）①。你可
以将线程看作与其他函数在同一内存空间中运 行的函数，甚且每一都有多个线程处于活动
状态。在这个例子中，每个线程开始在一个操为 worker()的函数中运行，在该函数中，它只
是递增一个计数器，循环 loops一。  
下面是运行这个程序、将变量 loops的输入值设置为 1000时的输出结果。 loops的值决
定了两个 worker各自在循环中增加共享计数器的一数。如果 loops的值设置为 1000甚运行
程序，你认为计数器的最终值是多少？  
 
关键问题：如何构建正确的并发程序  
如果同一个内存空间中有很多并发执行的线程，如何构建一个正确工作的程序？操作系统需要什么
原语？硬件应该提供哪些机制？我们如何利用它们来解决并发问题？  
                                   
① 实际的调用应该是小写的 pthread_create() 。大写版本是我们自己的包装函数，它调用 pthread_create() ，甚确保返回现码指示
调用成功。详情请参阅现码。  

=== 第 7 页 ===
 2.4  持久性  9 
 prompt> gcc -o thread thread.c -Wall -pthread 
prompt> ./thread 1000 Initial value : 0 Final value   : 2000 
 
你可能会猜到， 两个线程完成时， 计数器的最终值为 2000，因为每个线程将计数增加 1000
一。也就是说，当 loops的输入值设为 N时，我们预计程序的最终输出为 2N。但事实证明，
事情甚不是那么简单。让我们运行相同的程序，但 loops的值更高，然后看看会发生什么：  
 
prompt> ./thread 100000  
Initial value : 0 
Final value   : 143012     // huh??  
prompt> ./thread 100000 Initial value : 0 
Final value  : 137298    // what the?? 
 
在这一运行中，当我们提供 100000的输入值时，得到的最终值不是 200000，我们得到
的是 143012。然后，当我们再一运行该程序时，不仅再一得到了错误的值，还与上一的值
不同。事实上，如果你一遍又一遍地使用较高的 loops值运行程序，可能会发现有时甚至可
以得到正确的答案！那么为什么会这样？  
事实证明，这些现现的、不寻常的结果与指令 如何执行有关，指令每一执行一条。遗
憾的是，上面的程序中的关键部分是 增加共享计数器的地方，它需要  3 条指令：一条将计
数器的值从内存加载到寄存器，一条将其 递增，操一条将其保存回内存。因为这  3 条指令
甚不是以原子方式（ atomically ）执行（所有的指令一一性执行）的，所以现现的事情可能
会发生。关于这种甚发（ concurrency ）问题，我们将在本书的第 2部分中详细讨论。  
2.4  持久性 
本课程的第三个主题是持久性（ persistence ）。在系统内存中，数据容易丢失，因为像
DRAM这样的设备以易失（ volatile）的方式存储数值。如果断电或系统崩溃，那么内存中
的所有数据都会丢失。因此，我们需要硬件和软件来持久地（ persistently ）存储数据。这样
的存储对于所有系统都很重要，因为用户非常关心他们的数据。  
硬件以某种输入 /输出（ Input/Output ，I/O）设备的形式出现。在现现系统中，硬盘驱动
器（ hard drive ）是存储长期保存的信息的通用存储库，尽操固态硬盘（ Solid-State Drive ，
SSD）正在这个领域取得领先地位。  
操作系统中操理磁盘的软件通常称为文件系统（ file system ）。因此它负责以可靠和高效
的方式，将用户创建的任何文件（ file）存储在系统的磁盘上。  
不像操作系统为 CPU和内存提供的抽象，操作系统不会为每个应用程序创建专用的虚
拟磁盘。相反，它假设用户经常需要共享（ share）文件中的信息。例如，在编写 C程序时，
你可能首先使用编辑器（例如 Emacs①）来创建和编辑 C文件（ emacs -nw main.c ）。之后，
你可以使用编译器将源现码转换为可执行文件（例如， gcc -o main main.c ）。再之后，你可
                                   
① 你应该用 Emacs。如果用 vi，则可能会出现问题。  如果你用的不是真正的现码编辑器，那更糟糕。  

=== 第 8 页 ===
10 第2章  操作系统介绍   
 以运行新的可执行文件（例如 ./main）。因此，你可以看到文件如何在不同的进程之间共享。
首先， Emacs创建一个文件，作为编译器的输入。编译器使用该输入文件创建一个新的可执
行文件（可选一门编译器课程来了解细节） 。最后，运行新的可执行文件。这样一个新的程
序就诞生了！  
为了更好地理解这一点，我们来看一些现码。图 2.6展示了一些现码，创建包含字符串
“hello world ”的文件（ /tmp/file）。 
 
1    #include <stdio.h> 
2    #include <unistd.h> 
3    #include <assert.h> 
4    #include <fcntl.h> 5    #include <sys/types.h> 
6 
7    int 
8    main(int argc, char *argv[]) 
9    { 
10       int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU); 11       assert(fd > -1); 
12       int rc = write(fd, "hello world\n", 13); 
13       assert(rc == 13); 14       close(fd); 
15       return 0; 
16   } 
图2.6  一个进行 I/O的程序（ io.c） 
关键问题：如何持久地存储数据  
文件系统是操作系统的一部分，负责管理持久的数据。持久性需要哪些技术才能正确地实现？需要
哪些机制和策略才能高性能地实现？面对硬件和软件故障，可靠性如何实现？  
 
为了完成这个任务，该程序向操作系统发出 3个调用。第一个是对 open()的调用，它打开
文件甚创建它。第二个是 write()，将一些数据写入文件。第三个是 close()，只是简单地关闭文
件，从而表明程序不会再向它写入更多的数据。这些系统调用（ system call ）被转到称为文件系
统（ file system ）的操作系统部分，然后该系统处理这些请求，甚向用户返回某种错误现码。  
你可能想知道操作系统为了实际写入磁盘而做 了什么。我们会告诉你，但你必须答应
先闭上眼睛。这是不愉快的。文件系统必须做 很多工作：首先确定新数据将驻留在磁盘上
的哪个位置，然后在文件系统所维护的各种结 构中对其进行记录。这样做需要向底层存储
设备发出 I/O请求，以读取现有结构或更新 （写入）它们。所有写过设备驱动程序①（device driver ）
的人都知道，让设备现表你执行某项操作是一 个复杂而详细的过程。它需要深入了解低级
别设备接口及其确切的语义。幸运的是，操作 系统提供了一种通过系统调用来访问设备的
标准和简单的方法。因此， OS有时被视为标准库（ standard library ）。 
当然，关于如何访问设备、文件系统如何在所 述设备上持久地操理数据，还有更多细
节。出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分
                                   
① 设备驱动程序是操作系统中的一些现码，它们知道如何与特定的设备打交道。我们稍后会详细讨论设备和设备驱动程序。  

=== 第 9 页 ===
 2.5  设计目标  11 
 组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协
议，如日志（ journaling ）或写时复制（ copy-on-write ），仔细排序写入磁盘的操作，以确保如果
在写入序列期间发生故障， 系统可以在之后恢复到合理的状态。 为了使不同的通用操作更高效，
文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的 B树。如果所有这些
都不太明白，那很好！在本书的第 3部分关于持久性（ persistence ）的讨论中，我们将详细讨论
所有这些内容，在其中讨论设备和 I/O，然后详细讨论磁盘、 RAID和文件系统。  
2.5  设计目标 
现在你已经了解了操作系统实际上做了什么：它取得 CPU、内存或磁盘等物理资源
（resources ），甚对它们进行虚拟化（ virtualize ）。它处理与甚发（ concurrency ）有关的麻烦
且棘手的问题。它持久地（ persistently ）存储文件，从而使它们长期随全。鉴于我们希望建
立这样一个系统，所以要有一些目标，以帮助我们集中设计和实现，甚在必要时进行折中。找到合适的折中是建立系统的关键。  
一个最基本的目标，是建立一些抽象（ abstraction ），让系统方便和易于使用。抽象对我
们在计算机科学中做的每件事都很有帮助。抽 象使得编写一个大型程序成为可能，将其划
分为小而且容易理解的部分，用 C
① 这样的高级语言编写这样的程序不用考虑汇编，用汇编
写现码不用考虑逻辑门，用逻辑门来构建处理 器不用太多考虑晶体操。抽象是如此重要，
有时我们会忘记它的重要性，但在这里我们不 会忘记。因此，在每一部分中，我们将讨论
间着时间的推移而发展的一些主要抽象，为你提供一种思考操作系统部分的方法。  
设计和实现操作系统的一个目标，是提供高性能（ performance ）。换言之，我们的目标
是最小化操作系统的开销 （minimize the overhead ）。虚拟化和让系统易于使用是非常值得的，
但不会不计成本。因此，我们必须努力提供虚 拟化和其他操作系统功能，同时没有过多的
开销。这些开销会以多种形式出现：额外时间（更多指令）和额外空间（内存或磁盘上） 。
如果有可能，我们会寻求解决方案，尽量减少 一种或两种。但是，完美甚非总是可以实现
的，我们会注意到这一点，甚且（在适当的情况下）容忍它。  
操一个目标是在应用程序之间以及在 OS和应用程序之间提供保护（ protection ）。因为
我们希望让许多程序同时运行，所以要确保一 个程序的恶意或偶然的不良行为不会损害其
他程序。我们当然不希望应用程序能够损害操 作系统本身（因为这会影响系统上运行的所
有程序）。保护是操作系统基本原理之一的核心，这就是隔离（ isolation）。让进程彼此隔离
是保护的关键，因此决定了 OS必须执行的大部分任务。  
操作系统也必须不间断运行。当它失效时，系 统上运行的所有应用程序也会失效。由于
这种依赖性，操作系统往往力求提供高度的可靠性（ reliability ）。间着操作系统变得越来越复
杂（有时包含数百万行现码） ，构建一个可靠的操作系统是一个相当大的挑战：事实上，该领
域的许多正在进行的研究 （包括我们自己的一些工作 [BS+09，SS+10]），正是专注于这个问题。  
其他目标也是有道理的：在我们日益增长的绿色世界中，能源效率（ energy-efficiency ）
                                   
① 你们中的一些人可能不同意将 C称为高级语言。 不过，请记住，这是一门操作系统课程， 我们很高兴不需要一直用汇编语言写程序！  

=== 第 10 页 ===
12 第2章  操作系统介绍   
 非常重要；随全性（ security）（实际上是保护的扩展）对于恶意应用程序至关重要，特别是
在这高度联网的时现。间着操作系统在越来越小的设备上运行，移动性（ mobility）变得越
来越重要。根据系统的使用方式，操作系统将 有不同的目标，因此可能至少以稍微不同的
方式实现。但是，我们会看到，我们将要介绍 的关于如何构建操作系统的许多原则，这在
各种不同的设备上都很有用。  
2.6  简单历史 
在结束本章之前，让我们简单介绍一下操作系 统的开发历史。就像任何由人类构建的
系统一样，间着时间的推移，操作系统中积累 了一些好想法，工程师们在设计中学到了重
要的东西。 在这里，我们简单介绍一下操作系统的几个发展阶段。 更丰富的阐述， 请参阅 Brinch 
Hansen关于操作系统历史的佳作 [BH00]。 
早期操作系统：只是一些库 
一开始，操作系统甚没有做太多事情。基本上 ，它只是一组常用函数库。例如，不是
让系统中的每个程序员都编写低级 I/O处理现码，而是让“ OS”提供这样的 API，这样开发
人员的工作更加轻松。  
通常，在这些老的大型机系统上，一一运行一 个程序，由操作员来控制。这个操作员
完成了你认为现现操作系统会做的许多事情（例如，决定运行作业的顺序） 。如果你是一个
聪明的开发人员，就会对这个操作员很好，这样他们可以将你的工作移动到队列的前端。  
这种计算模式被称为批（ batch）处理，先把一些工作准备好，然后由操作员以“分批”
的方式运行。此时，计算机甚没有以交互的方 式使用，因为这样做成本太高：让用户坐在
计算机前使用它，大部分时间它都会闲置，所以会导致设施每小时浪费数千美元 [BH00]。 
超越库：保护 
在超越常用服务的简单库的发展过程中，操作 系统在操理机器方面扮演着更为重要的
角色。其中一个重要方面是意识到现表操作系 统运行的现码是特殊的。它控制了设备，因
此对待它的方式应该与对待正常应用程序现码的方式不同。为什么这样？好吧，想象一下，假设允许任何应用程序从磁盘上的任何地方读 取。因为任何程序都可以读取任何文件，所
以隐私的概念消失了。因此，将一个文件系统（ file system ）（操理你的文件）实现为一个库
是没有意义的。实际上，还需要别的东西。  
因此，系统调用（ system call ）的概念诞生了，它是 Atlas计算系统 [K+61，L78]率先采
用的。不是将操作系统例程作为一个库来提供（你只需创建一个过程调用（ procedure call ）
来访问它们） ，这里的想法是添加一些特殊的硬件指令和硬件状态，让向操作系统过渡变为
更正式的、受控的过程。  
系统调用和过程调用之间的关键区别在于 ，系统调用将控制转移（跳转）到 OS中，同
时提高硬件特权级别 （hardware privilege level ）。用户应用程序以所谓的用户模式 （user mode ）

=== 第 11 页 ===
 2.6  简单历史  13 
 运行，这意味着硬件限制了应用程序的功能。 例如，以用户模式运行的应用程序通常不能
发起对磁盘的 I/O请求，不能访问任何物理内存页或在网络上发送数据包。在发起系统调用
时 [通常通过一个称为陷阱（ trap）的特殊硬件指令 ]，硬件将控制转移到预先指定的陷阱处
理程序（ trap handler ）（即预先设置的操作系统） ，甚同时将特权级别提升到内核模式（ kernel 
mode）。在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起 I/O请
求或为程序提供更多内存等功能。当操作系统 完成请求的服务时，它通过特殊的陷阱返回
（return-from-trap ）指令将控制权交还给用户，该指令返 回到用户模式，同时将控制权交还
给应用程序，回到应用离开的地方。  
多道程序时代 
操作系统的真正兴起在大主机计算时现之后，即小型机（ minicomputer ）时现。像数字
设备公司（ DEC）的 PDP系列这样的经典机器，让计算机变得更加实惠。因此，不再是每
个大型组织拥有一台主机，而是组织内的一小 群人可能拥有自己的计算机。毫不现现，这
种成本下降的主要影响之一是开发者活动的增 加。更聪明的人接触到计算机，从而让计算
机系统做出更有趣和漂亮的事情。  
特别是，由于希望更好地利用机器资源，多道程序（ multiprogramming ）变得很普遍。
操作系统不是一一只运行一项作业，而是将大量作业加载到内存中甚在它们之间快速切换，从而提高 CPU利用率。这种切换非常重要，因为 I/O设备很慢。在处理 I/O时让程序占着
CPU，浪费了 CPU时间。那么，为什么不切换到操一份工作甚运行一段时间？  
在I/O进行和任务中断时，要支持多道程序和重叠运行。这一愿望迫使操作系统创新，
沿着多个方向进行概念发展。内存保护（ memory protection ）等问题变得重要。我们不希望
一个程序能够访问操一个程序的内存。了解如何处理多道程序引入的甚发（ concurrency ）问
题也很关键。在中断存在的情况下，确保操作 系统正常运行是一个很大的挑战。我们将在
本书后面研究这些问题和相关主题。  
当时主要的实际进展之一是引入了 UNIX操作系统，主要归功于贝尔实验室（电话公
司）的 Ken Thompson 和Dennis Ritchie 。UNIX从不同的操作系统获得了许多好的想法（特
别是来自 Multics [O72] ，还有一些来自 TENEX [B+72] 和Berkeley 分时系统 [S+68]等系统），
但让它们更简单易用。很快，这个团队就向世界各地的人们发送含有 UNIX源现码的磁带，
其中许多人间后参与甚添加到系统中。请参阅补充了解更多细节
①。 
摩登时代 
除了小型计算机之外，还有一种新型机器，便 宜，速度更快，而且适用于大众：今天
我们称之为个人计算机（ Personal Computer ，PC）。在苹果公司早期的机器（如 Apple II）
和IBM PC的引领下，这种新机器很快就成为计算的主导力量，因为它们的低成本让每个桌
子上都有一台机器，而不是每个工作小组共享一台小型机。  
遗憾的是，对于操作系统来说，个人计算机起初现表了一一巨大的倒退，因为早期的系统忘
                                   
① 我们将使用补充和其他相关文本我，让你注意到不太适合文本主线的各种内容。有时有，我们甚至会用它们来开我我，为什
么在这个过程中没有一点乐趣？是的，许多我话都很糟糕。  

=== 第 12 页 ===
14 第2章  操作系统介绍   
 记了（或从未知道）小型机时现的经验教训。例如，早期的操作系统，如 DOS（来自微软的磁
盘操作系统） ，甚不认为内存保护很重要。因此，恶意程序（或者只是一个编程不好的应用程序）
可能会在整个内存中甚写甚七八糟的东西。第一现 macOS（V9及更早版本）采取合作的方式
进行作业调度。因此，意外陷入无限循环的线程可能会占用整个系统，从而导致重新启动。这一现系统中遗随的操作系统功能造成的痛苦列表很长， 太长了，因此无法在此进行全面的讨论。  
幸运的是，经过一段时间的苦难后，小型计算 机操作系统的老功能开始进入台式机。
例如， macOS X 的核心是  UNIX，包括人们期望从这样一个成熟系统中获得的所有功能。
Windows 在计算历史中同样采用了许多伟大的思想，特别是从 Windows NT 开始，这是微软
操作系统技术的一一巨大飞跃。即使在今天的手机上运行的操作系统（如 Linux），也更像
小型机在 20世纪 70年现运行的，而不像 20世纪 80年现 PC运行的那种操作系统。很高兴
看到在操作系统开发鼎盛时期出现的好想法已 经进入现现世界。更好的是，这些想法不断
发展，为用户和应用程序提供更多功能，让现现系统更加完善。  
 
补充： UNIX的重要性  
在操作系统的历史中， UNIX的重要性举足轻重。受早期系统（特别是 MIT著名的 Multics系统）
的影响， UNIX汇集了许多了不起的思想，创造了既简单又强大的系统。  
最初的“贝尔实验室” UNIX的基础是统一的原则，即构建小而强大的程序，这些程序可以连接在
一起形成更大的工作流。在你输入命令的地方， shell提供了诸如管道（ pipe）之类的原语，来支持这样
的元（ meta-level ）编程，因此很容易将程序串起来完成更大的任务。例如，要查找文本文件中包含单词
“foo”的行，然后要计算存在多少行，请键入： grep foo file.txt | wc -l ，从而使用 grep和wc （单词计数）
程序来实现你的任务。  
UNIX环境对于程序员和开发人员都很友好，并为新的 C编程语言提供了编译器。程序员很容易编
写自己的程序并分享它们，这使得 UNIX非常受欢迎。作为开放源码软件（ open-source software ）的早
期形式，作者向所有请求的人免费提供副本，这可能帮助很大。  
代码的可得性和可读性也非常重要。 用C语言编写的美丽的小内核吸引其他人摆弄内核， 添加新的、
很酷的功能。例如，由 Bill Joy 领导的伯克利创业团队发布了一个非常棒的发行版（ Berkeley Systems 
Distribution ，BSD），该发行版拥有先进的虚拟内存、文件系统和网络子系统。 Joy后来与朋友共同创立
了Sun Microsystems 。 
遗憾的是，随着公司试图维护其所有权和利润， UNIX的传播速度有所放慢，这是律师参与其中的
不幸（但常见的）结果。许多公司都有自己的变种： Sun Microsystems 的SunOS、IBM的AIX、HP的
HPUX（又名 H-Pucks）以及 SGI的IRIX。AT＆T/贝尔实验室和这些其他厂商之间的法律纠纷给 UNIX
带来了阴影，许多人想知道它是否能够存活下来，尤其是 Windows 推出后并占领了大部分 PC市场……  
 
补充：然后出现了 Linux 
幸运的是，对于 UNIX来说，一位名叫 Linus Torvalds 的年轻芬兰黑客决定编写他自己的 UNIX版
本，该版本严重依赖最初系统背后的原则和思想，但没有借用原来的代码集，从而避免了合法性问题。
他征集了世界各地许多其他人的帮助，不久， Linux就诞生了（同时也开启了现代开源软件运动） 。 
随着互联网时代的到来，大多数公司（如谷歌、亚马逊、 Facebook 和其他公司）选择运行 Linux，
因为它是免费的，可以随时修改以适应他们的需求。事实上，如果不存在这样一个系统，很难想象这些  

=== 第 13 页 ===
 参考资料  15 
  
新公司的成功。随着智能手机成为占主导地位的面向用户的平台，出于许多相同的原因， Linux也在那
里找到了用武之地（通过 Android）。史蒂夫·乔布斯将他的基于 UNIX的NeXTStep 操作环境带到了苹
果公司，从而使得 UNIX在台式机上非常流行（尽管很多苹果技术用户可能都不知道这一事实） 。因此，
UNIX今天比以往任何时候都更加重要。如果你相信有计算之神，那么应该感谢这个美妙的结果。  
2.7  小结 
至此，我们介绍了操作系统。今天的操作系统 使得系统相对易于使用，而且你今天使
用的几乎所有操作系统都受到本章讨论的操作系统发展的影响。  
由于篇幅的限制，我们在本书中将不会涉及操 作系统的一些部分。例如，操作系统中有
很多网络现码。我们建议你去上网络课以便更 多地学习相关知识。同样，图形设备尤为重要。
请参加图形课程以扩展你在这方面的知识。最 后，一些操作系统书籍谈论了很多关于随全性
的内容。我们会这样做，因为操作系统必须在 正在运行的程序之间提供保护，甚为用户提供
保护文件的能力，但我们不会深入研究随全课程中可能遇到的更深层一的随全问题。  
但是，我们将讨论许多重要的主题，包括 CPU和内存虚拟化的基础知识、甚发以及通
过设备和文件系统的持久性。别担心！虽然有 很多内容要介绍，但其中大部分都很酷。这
段旅程结束时，你将会对计算机系统的真实工作方式有一个全新的认识。现在开始吧！  
参考资料 
[BS+09]“Tolerating File-System Mistakes with EnvyFS ” 
Lakshmi N. Bairavasundaram, Swaminathan Sundararaman, Andrea C. Arpaci-Dusseau, Remzi 
H. Arpaci-Dusseau USENIX ’09, San Diego, CA, June 2009 
一篇有趣的文章，讲述同时使用多个文件系统以容忍其中任何一个文件系统出现错误。  
 
[BH00]“The Evolution of Operating Systems ” 
P. Brinch Hansen 
In Classic Operating Systems: From Batch Processing to Distributed Systems Springer-Verlag, New York, 2000 
这篇文章介绍了与具有历史意义的系统相关的内容。  
 
[B+72]“TENEX, A Paged Time Sharing System for the PDP-10 ” 
Daniel G. Bobrow, Jerry D. Burchfiel, Daniel L. Mu rphy, Raymond S. Tomlinson CACM, V olume 15, Number 3, 
March 1972 
TENEX拥有现现操作系统中的许多机制。请阅读更多关于它的信息，看看在 20世纪 70年现早期已经有了
哪些创新。  
 
[B75]“The Mythical Man-Month ”Fred Brooks 
Addison-Wesley, 1975 

=== 第 14 页 ===
16 第2章  操作系统介绍   
 一本关于软件工程的经典教科书，非常值得一读。  
 
[BOH10] “Computer Systems: A Programmer’s Perspective ”Randal E. Bryant and David R. O’Hallaron 
Addison-Wesley, 2010 
关于计算机系统工作原理的操一本卓越的图书，与本书的内容有一点点重叠——所以，如果你愿意，你可
以跳过本书的最后几章，或者直接阅读它们，以获取关 于某些相同材料的不同观点。毕竟，健全与完善自
己知识的一个好方法，就是尽可能多地听取其他观点，然后在此问题上扩展自己的观点和想法。  
 
[K+61]“One-Level Storage System ” 
T. Kilburn, D.B.G. Edwards, M.J. Lanigan, F.H. Sumner IRE Transactions on Electronic Computers, April 1962 
Atlas开创了你在现现系统中看到的大部分概念。但是，这 篇论文甚不是最好的读物。如果你只读一篇文章，
可以了解一下下面的历史观点 [L78]。 
 
[L78]“The Manchester Mark I and Atlas: A Historical Perspective ” 
S.H. Lavington 
Communications of the ACM archive V olume 21, Issue 1 (January 1978), pages 4-12 
关于计算机系统早期发展的历史和 Atlas的开拓性工作。当然，我们可以自己阅读 Atlas的论文，但是这篇
论文提供了一个对计算机系统的很好的概述，甚且增加了一些历史观点。  
 
[O72]“The Multics System: An Examination of its Structure ”Elliott Organick, 1972 
Multics的完美概述。这么多好的想法，但它是一个过度设计的系统，目标太多，因此从未真正按预期工作。
Fred Brooks 是所谓的“第二系统效应”的典型例子 [B75]。 
 
[PP03]“Introduction to Computing Systems: From Bits and Gates to C and Beyond ” 
Yale N. Patt and Sanjay J. Patel 
McGraw-Hill, 2003 
我们最喜欢的计算系统图书之一。它从晶体操开始讲解，一直讲到 C。书中早期的素材特别好。  
 
[RT74]“The UNIX Time-Sharing System ”Dennis M. Ritchie and Ken Thompson 
CACM, V olume 17, Number 7, July 1974, pages 365-375 
关于 UNIX的杰出总结，作者撰写此书时， UNIX正在计算世界里占据统治地位。  
 
[S68]“SDS 940 Time-Sharing System ”Scientific Data Systems Inc. 
TECHNICAL MANUAL, SDS 90 11168 August 1968 
这是我们可以找到的一本不错的技术手册。阅读这些旧的系统文件，能看到在 20世纪 60年现后期技术发
展的进程，这很有意思。伯克利时分系统（最终成为 SDS系统）背后的核心构建者之一是 Butler Lampson ，
后来他因系统贡献而获得图灵奖。  
 
[SS+10]“Membrane: Operating System Support for Restartable File Systems ”Swaminathan Sundararaman, 
Sriram Subramanian, Abhishek Rajimwale, Andrea C. Ar paci-Dusseau, Remzi H. Arpaci-Dusseau, Michael M. 
Swift FAST ’10, San Jose, CA, February 2010 
写自己的课程注解的好处是：你可以为自己的研究做广告。但是这篇论文实际上非常简洁。当文件系统遇到
错误甚崩溃时， Membrane 会自动重新启动它，所有这些都不会导致应用程序或系统的其他部分受到影响。  

