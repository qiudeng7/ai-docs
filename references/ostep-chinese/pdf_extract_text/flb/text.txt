PDF 文件信息
==================================================
文件名: flb.pdf
标题: Microsoft Word - fl.doc
作者: gong40
创建者: PScript5.dll Version 5.2.2
生产者: Acrobat Distiller 7.0 (Windows)
总页数: 11

==================================================

文字内容
==================================================

=== 第 1 页 ===
 B.2  动机：为何用 VMM  455 
 附附录录BB    虚虚拟拟机机监监视视器器  
B.1  简介 
多年前， IBM将昂贵的大型机出售给大型组织，出现了一个问题：如果组织希望同时
在机器上运行不同的操作系统，该怎么办？有 些应用程序是在一个操作系统上开发的，有
些是在其他操作系统上开发的，因此出现了该问题。作为一种解决方案， IBM以虚拟机监
视器（ Virtual Machine Monitor ，VMM）（也称为管理程序， hypervisor ）[G74]的形式，引入
了另一个间接层。  
具体来说，监视器位于一个或多个操作系统和 硬件之间，并为每个运行的操作系统提
供控制机器的假象。然而，在幕后，实际上是 监视器在控制硬件，并必须在机器的物理资
源上为运行的 OS提供多路复用。实际上， VMM作为操作系统的操作系统，但在低得多层
次上。操作系统仍然认为它与物理硬件交互。因此，透明度（ transparency ）是 VMM的主
要目标。  
因此，我们发现自己处于一个有趣的位置：到 目前为止操作系统已经成为假象提供大
师，欺骗毫无怀疑的应用程序，让它们认为拥有自己私有的 CPU和大型虚拟内存，同时在
应用程序之间进行切换，并共享内存。现在， 我们必须再次这样做，但这次是在操作系统
之下，它曾经拥有控制权。 VMM如何为每个运行在其上的操作系统创建这种假象？  
 
关键问题：如何在操作系统之下虚拟化机器  
虚拟机监视器必须透明地虚拟化操作系统下的机器。这样做需要什么技术？  
 
B.2  动机：为何用 VMM 
今天，由于多种原因， VMM再次流行起来。服务器合并就是一个原因。在许多设置中，
人们在运行不同操作系统（甚至 OS版本）的不同机器上运行服务，但每台机器的利用率都
不高。在这种情况下，虚拟化使管理员能够将多个操作系统合并（ consolidate ）到更少的硬
件平台上，从而降低成本并简化管理。  
虚拟化在桌面上也变得流行，因为许 多用户希望运行一个操作系统（比如 Linux或
macOS X ），但仍然可以访问不同平台上的本机应用程序（比如 Windows ）。这种功能
（functionality ）上的改进也是一个很好的理由。  

=== 第 2 页 ===
456 附录 B  虚拟机监视器   
 另一个原因是测试和调试。当开发者在一个主平台上编写代码时，他们通常希望在许多不
同平台上进行调试和测试。在实际环境中，他们要将软件部署到这些平台上。因此，通过让开发人员能够在一台计算机上运行多种操作系统类型和版本，虚拟化可以轻松实现这一点。  
虚拟化的复兴始于 20世纪 90年代中后期，由 Mendel Rosenblum 教授领导的斯坦福大
学的一组研究人员推动。他的团队在用于 MIPS处理器的虚拟机监视器 Disco [B+97] 上的工
作是早期的努力，它使 VMM重新焕发活力，并最终使该团队成为 VMware [V98] 的创始人，
该公司现在是虚拟化技术的市场领导者。在本章中，我们将讨论 Disco的主要技术，并尝试
通过该窗口来了解虚拟化的工作原理。  
B.3  虚拟化 CPU 
为了在虚拟机监视器上运行虚拟机（ virtual machine ，即 OS及其应用程序） ，使用的基
本技术是受限直接执行 （limited direct execution ），这是我们在讨论操作系统如何虚拟化 CPU
时看到的技术。因此，如果想在 VMM之上“启动”新操作系统，只需跳转到第一条指令
的地址，并让操作系统开始运行，就这么简单。  
假设我们在单个处理器上运行，并且希望在两 个虚拟机之间进行多路复用，即在两个
操作系统和它们各自的应用程序之间进行多路 复用。非常类似于操作系统在运行进程之间
切换的方式（上下文切换， context switch ），虚拟机监视器必须在运行的虚拟机之间执行机
器切换（ machine switch ）。因此，当执行这样的切换时， VMM必须保存一个 OS的整个机
器状态（包括寄存器， PC，并且与上下文切换不同，包括所有特权硬件状态） ，恢复待运行
虚拟机的机器状态，然后跳转到待运行虚拟机的 PC，完成切换。注意，待运行 VM的PC
可能在 OS本身内（系统正在执行系统调用） ，或可能就在该 OS上运行的进程内（用户模
式应用程序） 。 
当正在运行的应用程序或操作系统尝试执行某种特权操作（ privileged operation ）时，
我们会遇到一些稍微棘手的问题。例如，在具有软件管理的 TLB的系统上，操作系统将使
用特殊的特权指令，用一个地址转换来更新 TLB，再重新执行遇到 TLB未命中的指令。在
虚拟化环境中， 不允许操作系统执行特权指令， 因为它控制机器而不是其下的 VMM。因此，
VMM必须以某种方式拦截执行特权操作的尝试，从而保持对机器的控制。  
如果在给定 OS上的运行进程尝试进行系统调用， 会出现 VMM必须如何介入某些操作
的简单场景。例如，进程可能尝试对一个文件调用 open()，或者可能调用 read()，从中获取
数据，或者可能正在调用 fork()来创建新进程。在没有虚拟化的系统中，通过特殊指令实现
系统调用。在 MIPS上，它是一个陷阱（ trap）指令。在 x86上，它是带有参数 0x80的int
（中断）指令。下面是 FreeBSD 上的 open库调用 [B00]（回想一下，你的 C代码首先对 C库
进行库调用，然后执行正确的汇编序列，实际发出陷阱指令并进行系统调用） ： 
 
open: 
    push    dword mode     push    dword flags     push    dword path 

=== 第 3 页 ===
 B.3  虚拟化 CPU 457 
     mov     eax, 5 
    push    eax     int     80h 
 
在基于 UNIX的系统上， open()只接受 3个参数： int open(char * path, int flags, mode_t mode) 。
你可以在上面的代码中看到 open()库调用是如何实现的：首先，将数据推入栈（模式，标志，
路径），然后将 5推入栈，然后调用 int 80h，它将控制权转移到内核。如果你想知道， 5是用户
模式应用程序与 FreeBSD 中open()系统调用的内核之间预先商定的约定。不同的系统调用会
在调用陷阱指令 int之前将不同的数字放在栈上（在相同的位置） ，从而进行系统调用①。 
执行陷阱指令时，正如之前讨论的那样，它通 常会做很多有趣的事情。在我们的示例
中，最重要的是它首先将控制转移 （即更改 PC）到操作系统内定义良好的陷阱处理程序 （trap 
handler）。操作系统开始启动时，会利用硬件（也是特权操作）建立此类例程的地址，因此
在后续的陷阱中，硬件知道从哪里开始运行代 码来处理陷阱。在陷阱的同时，硬件还做了
另一件至关重要的事情： 它将处理器的模式从用户模式 （user mode ）更改为内核模式 （kernel 
mode）。在用户模式下，操作受到限制，尝试执行特权操作将导致陷阱，并可能终止违规进
程。另一方面，在内核模式下，机器的全部能 力都可用，因此可以执行所有特权操作。因
此，在传统设置中（同样，没有虚拟化） ，控制流程如表 B.1所示。  
表 B.1  执行系统调用 
进程 硬件 操作系统  
1．执行指令  
（add, load, 等）  
2．系统调用：  
陷入 OS   
 3．切换到内核模式  
跳转到陷阱处理程序   
  4．在内核模式  
处理系统调用  
从陷阱返回  
 5．切换到用户模式  
返回用户模式   
6．继续执行  
（@陷阱之后的 PC）   
 
在虚拟化平台上，事情会更有趣。如果在 OS上运行的应用程序希望执行系统调用，它
会执行完全相同的操作：执行陷阱指令，并将参数小心地放在栈上（或寄存器中） 。但是，
VMM控制机器，因此安装了陷阱处理程序的 VMM将首先在内核模式下执行。  
那么 VMM应该如何处理这个系统调用呢？ VMM并不真正知道如何（ how）处理调用。
毕竟，它不知道正在运行的每个操作系统的细 节，因此不知道每个调用应该做什么。然而，
VMM知道的是 OS的陷阱处理程序在哪里 （where）。它知道这一点， 因为当操作系统启动时，
它试图安装自己的陷阱处理程序。当操作系统 这样做时，它试图执行一些特权操作，因此陷
                                   
① 使用术语“中断”来表示几乎任何理智的人都会称之为陷阱的指令，这让事情变得混乱。正如 Patterson 曾说英特尔指令集
是“只有母亲才爱的 ISA。”但实际上，我们有点喜欢它，但我们不是它的母亲。  

=== 第 4 页 ===
458 附录 B  虚拟机监视器   
 入VMM中。那时， VMM记录了必要的信息（即这个 OS的陷阱处理程序在内存中的位置） 。
现在，当 VMM从在给定操作系统上运行的用户进程接收 到陷阱时，它确切地知道该做什么：
它跳转到操作系统的陷阱处理程序，并让操作系统按原样处理系统调用。当操作系统完成时，它会执行某种特权指令从陷阱返回 （在 MIPS上是 rett，在x86上是 iret），然后再次弹回 VMM，
然后 VMM意识到操作系统正试图从陷阱返回，从而执行一次真正的从陷阱返回，从而将控
制返回给用户，并让机器返回用户模式。表 B.2和表 B.3描述了整个过程，无论是没有虚拟
化的正常情况，还是虚拟化的情况（上面省略了具体的硬件操作，以节省空间） 。 
表 B.2   没有虚拟化的系统调用流程 
进程 操作系统  
1．系统调用：  
陷入 OS  
 2．OS陷阱处理程序：  
解码陷阱并执行相应的系统调用例程；  
完成后，从陷阱返回  
3．继续执行（ @陷阱之后的 PC）  
  
表 B.3   有虚拟化的系统调用流程 
进程 操作系统  VMM 
1．系统调用：  
陷入 OS   
  2．进程陷入：  
调用 OS陷阱处理程序  
（以减少的特权）  
 3．OS陷阱处理程序：  
解码陷阱并执行系统调用  
完成后：发出从陷阱返回   
  4．OS尝试从陷阱返回：  
真正从陷阱返回  
5．继续执行（ @陷阱之后的 PC）   
 
从表中可以看出，虚拟化时必须做更多的工作 。当然，由于额外的跳转，虚拟化可能
确实会减慢系统调用，从而可能影响性能。  
你可能还注意到，我们还有一个问题：操作系 统应该运行在什么模式？它无法在内核
模式下运行，因为这可以无限制地访问硬件。因此，它必须以比以前更少的特权模式运行，能够访问自己的数据结构，同时阻止从用户进程访问其数据结构。  
在Disco的工作中， Rosenblum 及其同事利用 MIPS硬件提供的特殊模式（称为管理员模
式），非常巧妙地处理了这个问题。在此模式下运行时，仍然无法访问特权指令，但可以访问
比在用户模式下更多的内存。操作系统可以将这个额外的内存用于其数据结构，一切都很好。在没有这种模式的硬件上，必须以用户模式运行 OS并使用内存保护（页表和 TLB），来适当
地保护 OS的数据结构。换句话说，当切换到 OS时，监视器必须通过页表保护，让 OS数据

=== 第 5 页 ===
 B.4  虚拟化内存  459 
 结构的内存对 OS可用。当切换回正在运行的应用程序时，必须删除读取和写入内核的能力。  
B.4  虚拟化内存 
你现在应该对处理器的虚拟化方式有了基本的了解： VMM就像一个操作系统，安排不
同的虚拟机运行。当特权级别发生变化时，会 发生一些有趣的交互。但我们忽略了很大一
部分： VMM如何虚拟化内存？  
每个操作系统通常将物理内存视为一个线性的 页面数组，并将每个页面分配给自己或
用户进程。当然，操作系统本身已经为其运行 的进程虚拟化了内存，因此每个进程都有自
己的私有地址空间的假象。现在我们必须添加 另一层虚拟化，以便多个操作系统可以共享
机器的实际物理内存，我们必须透明地这样做。  
这个额外的虚拟化层使“物理”内存成为一个虚拟化层，在 VMM所谓的机器内存
（machine memory ）之上，机器内存是系统的真实物理内存。因此，我们现在有一个额外
的间接层：每个操作系统通过其每个 进程的页表映射虚拟到物理地址， VMM通过它的每
个OS页面表，将生成的物理地址映射到底层机器地址。图 B.1描述了这种额外的间接层。  
 
图B.1  VMM 内存虚拟化  
在该图中，只有一个虚拟地址空间，包含 4个页面，其中 3个是有效的（ 0、2和3）。
操作系统使用其页面表将这些页面映射到 3个底层物理帧（分别为 10、3和8）。在 OS之
下， VMM提供进一步的间接级别，将 PFN 3、8和10分别映射到机器帧 6、10和5。当然，
这张图简化了一些事情。在真实系统上，会运行 V个操作系统（ V可能大于 1），因有此 V
个VMM页表。此外，在每个运行的操作系统 OSi之上，将有许多进程 Pi运行（ Pi可能是
数十或数百） ，因此 OSi内有 Pi个（每进程）页表。  
为了理解它如何更好地工作，让我们回想一下地址转换（ address translation ）在现代分
页系统中的工作原理。具体来说，让我们讨论在具有软件管理的 TLB的系统上，在地址转

=== 第 6 页 ===
460 附录 B  虚拟机监视器   
 换期间发生的情况。假设用户进程生成一个地址（用于指令获取或显式加载或存储） 。根据
定义，该进程生成虚拟地址（ virtual address ），因为其地址空间已由 OS虚拟化。如你所知，
操作系统的作用是在硬件的帮助下将其转换为物理地址（ virtual address ），从而能够从物理
内存中获取所需的内容。  
假设有一个 32位的虚拟地址空间和 4-KB的页面大小。因此， 32位地址被分成两部分：
一个 20位的虚拟页号（ VPN）和一个 12位的偏移量。在硬件 TLB的帮助下， OS的作用是
将VPN转换为有效的物理页帧号（ PFN），从而产生完全形式的物理地址，可以将其发送到
物理内存以获取正确的数据。在通常情况下，我们希望 TLB能够处理硬件中的转换，从而
快速实现转换。当 TLB未命中时（至少在具有软件管理的 TLB的系统上） ，操作系统必须
参与处理未命中，如表 B.4所示。  
表 B.4   没有虚拟化的 TLB 未命中流程 
进程 操作系统  
1．从内存加载：  
TLB未命中：陷阱   
 2．OS TLB未命中处理程序：  
从VA提取 VPN 
查找页表  
如果存在并有效，则取得 PFN，更新 TLB； 
从陷阱返回  
3．继续执行（ @导致陷入的指令的 PC） 
指令重试  
导致 TLB命中   
 
如你所见， TLB未命中会导致陷入操作系统，操作系统在页表中查找 VPN，将转换映
射装入 TLB，来处理该故障。  
然而，操作系统之下有虚拟机监视器时，事情变得更有趣了。我们再来看看 TLB未命
中的流程（参见表 B.5的总结）。当进程进行虚拟内存引用，并导致 TLB未命中时，运行的
不是 OS TLB的未命中处理程序。实际上，运行的是 VMM TLB 未命中处理程序，因为 VMM
是机器的真正特权所有者。但是，在正常情况下， VMM TLB 处理程序不知道如何处理 TLB
未命中，因此它立即跳转到 OS TLB未命中处理程序。 VMM知道此处理程序的位置，因为
操作系统在 “启动”期间尝试安装自己的陷阱处理程序。 然后运行 OS TLB未命中处理程序，
对有问题的 VPN执行页表查找，并尝试在 TLB中安装 VPN到PFN映射。但是，这样做是
一种特权操作，因此导致另一次陷入 VMM（当任何非特权代码尝试执行特权时， VMM都
会得到通知） 。此时， VMM玩了花样： VMM不是安装操作系统的 VPN-to-PFN 映射，而是
安装其所需的 VPN-to-MFN 映射。这样做之后，系统最终返回到用户级代码，该代码重试
该指令，并导致 TLB命中，从数据所在的机器帧中获取数据。  
表 B.5  有虚拟化的 TLB 未命中流程 
进程 操作系统  虚拟机监视器  
1．从内存加载  
TLB未命中：陷阱    

=== 第 7 页 ===
 B.4  虚拟化内存  461 
 续表 
进程 操作系统  虚拟机监视器  
  2．VMM TLB 未命中处理程序：  
调用 OS TLB处理程序（减少的特权）  
 3．OS TLB未命中处理程序：
从VA提取 VPN 
查找页表  
如果存在并有效：取得 PFN，
更新 TLB  
  4．陷阱处理程序：  
非特权代码尝试更新 TLB 
OS在尝试安装 VPN到PFN的映射  
用VPN-to-MFN 更新 TLB（特权操作）  
跳回 OS（减少的特权）  
 5．从陷阱返回   
  6．陷阱处理程序：  
非特权指令尝试从陷阱返回  
从陷阱返回  
7．继续执行（ @导致陷入的指
令的 PC） 
指令重试  
导致 TLB命中    
 
这组操作还暗示了，对于每个正在运行的操作系统的物理内存， VMM必须如何管理虚
拟化。就像操作系统有每个进程的页表一样， VMM必须跟踪它运行的每个虚拟机的物理到
机器映射。在 VMM TLB 未命中处理程序中，需要查阅每个机器的页表，以便确定特定“物
理”页面映射到哪个机器页面，甚至它当前是否存在于机器内存中（例如， VMM可能已将
其交换到磁盘） 。 
 
补充：管理程序和硬件管理的 TLBS  
我们的讨论集中在软件管理的 TLB以及发生未命中时需要完成的工作。但你可能想知道：有硬件
管理的 TLB时，虚拟机监视器如何参与？在这些系统中，硬件在每个 TLB未命中时遍历页表并根据需
要更新 TLB，因此 VMM没有机会在每个 TLB未命中时运行以将其转换到系统中。作为替代， VMM必
须密切监视操作系统对每个页表的更改（在硬件管理的 系统中，由某种类型的页表基址寄存器指向） ，
并保留一个影子页表（ shadow page table ），它将每个进程的虚拟地址映射到 VMM期望的机器页面
[AA06]。每当操作系统尝试安装进程的操作系统级页表时， VMM就会安装进程的影子页表，然后硬件
干活，利用影子表将虚拟地址转换为机器地址，而操作系统甚至没有注意到。  
 
最后，你可能注意到，在这一系列操作中，虚拟化系统上的 TLB未命中变得比非虚拟
化系统更昂贵一点。为了降低这一成本， Disco的设计人员增加了一个 VMM级别的“软件
TLB”。这种数据结构背后的想法很简单。 VMM记录它看到操作系统尝试安装的每个虚拟
到物理的映射。然后，在 TLB未命中时， VMM首先查询其软件 TLB以查看它是否已经看

=== 第 8 页 ===
462 附录 B  虚拟机监视器   
 到此虚拟到物理映射，以及 VMM所需的虚拟到机器的映射应该是什么。如果 VMM在其
软件 TLB中找到转换，就将虚拟到机器的映射直接装入硬件 TLB中，因此跳过了上面控制
流中的所有来回 [B+97]。 
B.5  信息沟 
操作系统不太了解应用程序的真正需求，因此 通常必须制定通用的策略，希望对所有
程序都有效。类似地， VMM通常不太了解操作系统正在做什么或想要什么，这种知识缺乏
有时被称为 VMM和OS之间的信息沟（ information gap ），可能导致各种低效率 [B+97]。例
如，当 OS没有其他任何东西可以运行时，它有时会进入空循环（ idle loop），只是自旋并等
待下一个中断发生：  
 
while (1) 
  ; // the idle loop 
 
如果操作系统负责整个机器，因此知道没有其他任务需要运行，这样旋转是有意义的。
但是，如果 VMM在两个不同的操作系统下运行，一个在空循环中，另一个在运行有用的
用户进程，那么 VMM知道一个操作系统处于空闲状态会很有用，这样可以为做有用工作
的操作系统提供更多的 CPU时间。  
 
补充：半虚拟化  
在许多情况下，最好是假定，无法为了更好地使用虚拟机监视器而修改操作系统（例如，因为你在
不友好的竞争对手的操作系统下运行 VMM）。但是，情况并非总是如此。如果可以修改操作系统（正如
我们在页面按需置零的示例中所见） ，它可能在 VMM上更高效地运行。运行修改后的操作系统，以便
在VMM上运行，这通常称为半虚拟化（ para-virtualization ）[WSG02] ，因为 VMM提供的虚拟化不是
完整的虚拟化，而是需要操作系统更改才能有效运行的部分虚拟化。研究表明，一个设计合理的半虚拟
化系统，只需要正确的操作系统更改，就可以接近没有 VMM时的效率 [BD+03]。 
 
另一个例子是页面按需置零。大多数操作系统 在将物理帧映射到进程的地址空间之前
将其置零。这样做的原因很简单：安全性。如 果操作系统为一个进程提供了另一个已经使
用的页面，但没有将其置零，则可能会发生跨 进程的信息泄露，从而可能泄露敏感信息。
遗憾的是，出于同样的原因， VMM必须将它提供给每个操作系统的页面置零，因此很多时
候页面将置零两次，一次由 VMM分配给操作系统，一次由操作系统分配给操作系统的一
个进程。 Disco的作者没有很好地解决这个问题的方法：他们只是简单地将操作系统（ IRIX）
改为不对页面置零，因为知道已被底层 VMM [B+97] 置零。  
类似这样的问题，这里描述的还有很多。一种解决方案是 VMM使用推理（一种隐含
信息， implicit information ）来克服该问题。例如， VMM可以通过注意到 OS切换到低功率
模式来检测空闲循环。在半虚拟化（ para-virtualized ）系统中，还有另一种方法，需要更改
操作系统。这种更明确的方法虽然难以实施，但却非常有效。  

=== 第 9 页 ===
 参考资料  463 
 B.6  小结 
虚拟化正在复兴。出于多种原因，用户和管理 员希望同时在同一台计算机上运行多个
操作系统。关键是 VMM通常透明地（ transparently ）提供服务，上面的操作系统完全不知
道它实际上并没有控制机器的硬件。 VMM使用的关键方法是扩展受限直接执行的概念。通
过设置硬件，让 VMM能够介入关键事件（例如陷阱） ，VMM可以完全控制机器资源的分
配方式，同时保留操作系统所需的假象。  
 
提示：使用隐含信息  
隐含信息可以成为分层系统中的一个强大工具，在这种系统中很难改变系统之间的接口，但需要更
多关于系统不同层的信息。例如，基于块的磁盘设备，可能想了解更多关于它上面的文件系统如何使用
它的信息。同样，应用程序可能想知道文件系统页面缓存中当前有哪些页面，但操作系统不提供访问此
信息的 API。在这两种情况下，研究人员都开发了强大的推理技术，来隐式收集所需的信息，而无需在
层[AD+01，S+03]之间建立明确的接口。这些技术在虚拟机监视器中非常有用，它希望了解有关在其上
运行的 OS的更多信息，而无需在两个层之间使用显式 API。 
 
你可能已经注意到，操作系统为进程执行的操作与 VMM为操作系统执行的操作之间
存在一些相似之处。它们毕竟都是虚拟化硬件 ，因此做了一些相同的事情。但是，有一个
关键的区别：通过操作系统虚拟化，提供了许多新的抽象和漂亮的接口。使用 VMM级虚
拟化，抽象与硬件相同（因此不是很好） 。虽然 OS和VMM都虚拟化硬件，但它们通过提
供完全不同的接口来实现。与操作系统不同， VMM没有特别打算让硬件更易于使用。  
如果你想了解有关虚拟化的更多信息，还有许 多其他主题需要研究。例如，我们甚至
没有讨论 I/O会发生什么，这个主题在虚拟化平台方面有一些有趣的新问题。我们也没有讨
论操作系统“作为兼职”运行在有时称为“托 管”配置中，虚拟化如何工作。如果你感兴
趣，请阅读有关这两个主题的更多信息 [SVL01]。我们也没有讨论，如果 VMM上运行的一
些操作系统占用太多内存，会发生什么。  
最后，硬件支持改变了平台支持虚拟化的方式。英特尔和 AMD等公司现在直接支持额
外的虚拟化层，从而避免了本章中的许多软件 技术。也许，在尚未撰写的一章中，我们会
更详细地讨论这些机制。  
参考资料 
[AA06]“A Comparison of Software and Hardware Techniques for x86 Virtualization ” 
Keith Adams and Ole Agesen 
ASPLOS ’06, San Jose, California 
来自两位 VMware 工程师的一篇优秀的论文， 讲述了为虚拟化提供硬件支持所带来的惊人的小优势。 此外，
还有关于 VMware 虚拟化的一般性讨论，包括为了虚拟化难以虚拟化的 x86平台，而必须采用的疯狂的二

=== 第 10 页 ===
464 附录 B  虚拟机监视器   
 进制翻译技巧。  
 
[AD+01] “Information and Control in Gray-box Systems ”Andrea C. Arpaci-Dusseau and Remzi H. 
Arpaci-Dusseau SOSP ’01, Banff, Canada 
我们自己的工作是如何推断信息，甚至从应用程序级别 对操作系统施加控制，而不对操作系统进行任何更
改。其中最好的例子：使用基于概率探测器的技术确定在 OS中缓存哪些文件块。这样做可以让应用程序
更好地利用缓存，优先安排会导致命中的工作。  
 
[B00]“FreeBSD Developers’ Handbook: 
Chapter 11 x86 Assembly Language Programming ” 
一本 BSD开发者手册中关于系统调用的很好的教程。  
 
[BD+03]“Xen and the Art of Virtualization ” 
Paul Barham, Boris Dragovic, Keir Fraser, Steven Hand, Tim Harris, Alex Ho, Rolf Neuge- bauer, Ian Pratt, 
Andrew Warfield SOSP ’03, Bolton Landing, New York 
该论文表明，对于半虚拟化系统，虚拟化系统的开销可以低得令人难以置信。这篇关于 Xen虚拟机监视器
的论文如此成功，导致了一家公司的诞生。  
 
[B+97]“Disco: Running Commodity Operating Systems on Scalable Multiprocessors ” 
Edouard Bugnion, Scott Devine, Kinshuk Govil, Mendel Rosenblum 
SOSP ’97 
将系统社区重新带回虚拟机研究的论文。好吧，也许这是不公平的，因为 Bressoud 和Schneider [BS95] 也
做了，但在这里我们开始理解为什么虚拟化会回来。然 而更令人瞩目的是，这群优秀的研究人员创立了
VMware，赚取了数十亿美元。  
 
[BS95]“Hypervisor-based Fault-tolerance ”Thomas C. Bressoud, Fred B. Schneider SOSP ’95 
最早引入虚拟机管理程序（ hypervisor
，这只是虚拟机监视器的另一个术语）的论文之一。然而，在这项工
作中，这些管理程序用于提高硬件故障的系统容忍度， 这可能不如本章讨论的一些更实际的场景有用。但
它本身仍然是一篇非常有趣的论文。  
 
[G74]“Survey of Virtual Machine Research ” 
R.P. Goldberg 
IEEE Computer, V olume 7, Number 6 
一份对许多老的虚拟机研究的调查。  
 
[SVL01]“Virtualizing I/O Devices on VMware Workstation’s Hosted Virtual Machine Monitor ” 
Jeremy Sugerman, Ganesh Venkitachalam and Beng-Hong Lim 
USENIX ’01, Boston, Massachusetts 
本文很好地概述了在使用托管体系结构的 VMware 中I/O的工作方式。该体系结构利用了许多操作系统自
身的功能，避免了在 VMM中重新实现它们。  
 

=== 第 11 页 ===
 参考资料  465 
 [V98] VMware corporation. 
这可能是本书中最无价值的参考资料，因为你可以自己阅读一下。但无论如何，该公司成立于 1998年，是
虚拟化领域的领导者。  
 
[S+03]“Semantically-Smart Disk Systems ” 
Muthian Sivathanu, Vijayan Prabhakaran, Florentina I. Popovici, Timothy E. Denehy, Andrea 
C. Arpaci-Dusseau, Remzi H. Arpaci-Dusseau FAST ’03, San Francisco, California, March 2003 
又是我们的工作，这次展示了一个基于块的设备如何能 够推断出它上面的文件系统正在做什么，例如删除
文件。其中使用的技术在块设备内实现了有趣的新功能，例如安全删除或更可靠的存储。  
 
[WSG02] “Scale and Performance in th e Denali Isolation Kernel ”Andrew Whitaker, Marianne Shaw, and Steven D. 
Gribble 
OSDI ’02, Boston, Massachusetts 
介绍术语半虚拟化的论文。虽然人们可以争辩说 Bugnion 等人 [B+97]在Disco论文中介绍了半虚拟化的概
念，但 Whitaker 等人进一步说明，这个想法的通用性如何超出以前的想象。  
 

