# 第11章：并发和锁

## 概述

并发编程是现代操作系统中的核心概念。当多个线程同时访问共享资源时，可能会出现竞态条件（race condition），导致程序行为不可预测。为了解决这些问题，我们需要引入同步机制，其中锁是最基本的同步原语之一。

## 并发的问题

### 竞态条件

竞态条件发生在两个或多个线程并发地访问共享数据，并且至少有一个线程在修改数据时。如果没有适当的同步，最终的执行结果取决于线程的相对执行顺序，这可能导致不正确的结果。

### 临界区

临界区是指访问共享资源的代码段。为了保证程序的正确性，我们必须确保任何时候只有一个线程能够执行临界区代码。

## 锁的基本概念

锁是一种同步机制，用于保护临界区，防止多个线程同时进入。锁提供两种基本操作：

1. **获取锁（acquire）**：在进入临界区之前获取锁
2. **释放锁（release）**：在退出临界区时释放锁

### 锁的使用模式

```c
lock_t mutex;  // 声明锁

lock_init(&mutex);  // 初始化锁

// 线程代码
lock(&mutex);  // 获取锁
// 临界区代码
// 访问共享资源
unlock(&mutex);  // 释放锁
```

## 锁的实现

### 评价锁的标准

一个良好的锁实现应该满足以下标准：

1. **互斥性**：任何时刻只有一个线程能持有锁
2. **公平性**：等待锁的线程应该公平地获得锁
3. **性能**：锁操作不应该显著影响程序性能

### 简单的锁实现

#### 使用禁用中断

```c
void lock() {
    disable_interrupts();
}

void unlock() {
    enable_interrupts();
}
```

**缺点**：
- 只适用于单处理器系统
- 长时间禁用中断会影响系统响应性
- 不适合用户级程序

#### 使用测试并设置指令（Test-and-Set）

```c
int TestAndSet(int *ptr, int new) {
    int old = *ptr;
    *ptr = new;
    return old;
}

typedef struct __lock_t {
    int flag;
} lock_t;

void init(lock_t *lock) {
    lock->flag = 0;
}

void lock(lock_t *lock) {
    while (TestAndSet(&lock->flag, 1) == 1)
        ;  // 自旋等待
}

void unlock(lock_t *lock) {
    lock->flag = 0;
}
```

#### 使用比较并交换指令（Compare-and-Swap）

```c
int CompareAndSwap(int *ptr, int expected, int new) {
    int actual = *ptr;
    if (actual == expected)
        *ptr = new;
    return actual;
}

void lock(lock_t *lock) {
    while (CompareAndSwap(&lock->flag, 0, 1) == 1)
        ;  // 自旋等待
}
```

### 更完善的锁实现

#### 使用队列锁

Ticket Lock是一种公平的锁实现：

```c
typedef struct __lock_t {
    int ticket;
    int turn;
} lock_t;

void lock_init(lock_t *lock) {
    lock->ticket = 0;
    lock->turn = 0;
}

void lock(lock_t *lock) {
    int myturn = FetchAndIncrement(&lock->ticket);
    while (lock->turn != myturn)
        ;  // 自旋等待
}

void unlock(lock_t *lock) {
    lock->turn = lock->turn + 1;
}
```

## 锁的性能问题

### 自旋锁的问题

自旋锁在锁被占用时会持续消耗CPU资源。当锁被持有的时间较长时，自旋等待会浪费大量CPU周期。

### 解决方案

1. **让出CPU**：在等待时让出CPU给其他线程
2. **混合锁**：结合自旋和阻塞的优点的锁实现

## 死锁

### 死锁的定义

死锁是指两个或多个线程互相等待对方释放资源，导致所有线程都无法继续执行的情况。

### 死锁的四个必要条件

1. **互斥条件**：资源不能被多个线程同时使用
2. **占有并等待**：线程持有资源的同时等待其他资源
3. **不可抢占**：资源不能被强制性地从持有者手中夺走
4. **循环等待**：存在一个线程资源的循环等待链

### 预防死锁的策略

1. **破坏循环等待**：定义资源获取的全局顺序
2. **破坏占有并等待**：原子性地获取所有需要的资源
3. **破坏不可抢占**：允许资源被抢占
4. **破坏互斥条件**：使用可共享的资源（如果可能）

## 实际应用中的考虑

### 锁的粒度

1. **粗粒度锁**：使用少量的大锁，保护大量资源
   - 优点：实现简单，开销小
   - 缺点：并发性差

2. **细粒度锁**：使用大量的小锁，分别保护不同的资源
   - 优点：并发性好
   - 缺点：实现复杂，开销大，容易产生死锁

### 锁的使用原则

1. **最小化临界区**：临界区应该尽可能小
2. **避免嵌套锁**：尽量减少同时持有多个锁的情况
3. **一致的获取顺序**：如果必须使用多个锁，总是按相同顺序获取
4. **及时释放锁**：不在临界区内执行不必要的操作

## 总结

锁是并发编程中的基本同步机制。一个好的锁实现需要在互斥性、公平性和性能之间找到平衡。在实际应用中，我们需要根据具体场景选择合适的锁策略，并注意避免死锁等并发问题。

理解锁的工作原理和正确使用锁对于开发可靠的并发程序至关重要。随着多核处理器的普及，掌握这些概念变得越来越重要。