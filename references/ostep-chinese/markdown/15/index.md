# 第15章 空闲空间管理

> 追求真理，其代价就是必须同时接受大量的谬误。
>
> — T.S. Eliot

## 本章概述

在本章中，我们将探讨操作系统如何管理空闲内存。当你运行一个进程并需要分配内存时，操作系统必须能够找到空闲的内存块来满足请求。当进程释放内存时，操作系统必须能够回收这些内存并将其标记为可用。这个过程被称为**空闲空间管理**（free-space management）。

我们首先讨论基本的机制，然后分析一些不同方法如何平衡时间和空间效率。最后，我们将讨论其他问题，如外部碎片和物理内存管理等概念，这些都超出了简单管理自由列表的范畴。

## 15.1 假设

为了讨论空闲空间管理，我们假设开发人员正在使用标准内存分配库，如`malloc()`和`free()`。在这些调用背后，操作系统维护着一个**空闲列表**（free list），这个列表包含所有当前未使用的内存区域的引用。

当调用`malloc()`时，内存分配库会从空闲列表中找到一个足够大的空闲块来满足请求。它可能会分割这个块，将请求的部分返回给用户，并将剩余部分保留在空闲列表中。当调用`free()`时，分配库会将返回的内存块添加回空闲列表。

## 15.2 低级机制

### 15.2.1 分割与合并

空闲空间管理的基本操作是**分割**（splitting）和**合并**（coalescing）。

当分配内存时，如果找到一个比请求大小更大的空闲块，通常会将其分割成两部分：一部分用于满足当前请求，另一部分作为新的、较小的空闲块保留在列表中。

当释放内存时，一个关键操作是**合并相邻的空闲块**。如果一个被释放的块与相邻的块也是空闲的，那么应该将它们合并成一个更大的空闲块。这有助于避免**外部碎片**（external fragmentation），即内存中存在许多小的、无法利用的空闲块。

### 15.2.2 嵌入空闲列表

一个重要的实际问题是：空闲列表本身存储在哪里？一种常见的方法是将空闲列表信息**嵌入**到可用的内存块中。具体来说，每个空闲块的开头包含一个**头部**（header），其中存储有关该块的信息（如大小）以及指向列表中下一个空闲块的指针。

这种方法的优点是不需要额外的内存来维护空闲列表；它利用了已经空闲的空间。缺点是它增加了每个块的最小大小（因为必须为头部留出空间），并且可能使头部信息本身容易受到破坏的影响。

### 15.2.3 寻找空闲空间

当需要分配内存时，系统必须决定如何从空闲列表中选择合适的块。以下是几种常见的策略：

1. **首次适应**（First Fit）：扫描空闲列表，选择第一个足够大的块。
2. **最佳适应**（Best Fit）：扫描整个列表，选择最小的足够大的块。
3. **最差适应**（Worst Fit）：选择最大的可用块。
4. **下次适应**（Next Fit）：从上次搜索结束的地方开始扫描。

每种策略都有其优缺点，我们将在稍后讨论。

## 15.3 空闲列表技术

### 15.3.1 简单链表式空闲列表

最基本的方法是使用**双向链表**来维护空闲块。每个空闲块包含指向列表中前后空闲块的指针。

这种方法的优点是简单，允许轻松的插入和删除。缺点是可能需要线性扫描列表来找到合适的块。

### 15.3.2 分离空闲列表

**分离空闲列表**（segregated free lists）技术维护多个空闲列表，每个列表包含特定大小的块。例如，可以有一个列表用于小块（16-32字节），另一个用于中等块（33-64字节），等等。

这种方法减少了搜索时间，因为分配器可以快速找到适合请求大小的列表。它还可以减少外部碎片，因为相似大小的块被分组在一起。

### 15.3.3 伙伴系统

**伙伴系统**（buddy system）是另一种管理空闲空间的技术。在这种方法中，内存被分成2的幂次大小的块。每个块都有一个"伙伴"——相同大小的相邻块。

当分配块时，系统找到大小足够的最小2的幂次块。如果这个块太大，它会递归地分成两半，直到达到合适的大小。当释放块时，系统会检查其伙伴是否也是空闲的；如果是，它们会被合并成更大的块。

### 15.3.4 其他技术

还有其他更高级的技术，如：

- **二叉树**：使用二叉搜索树来维护空闲块，按大小或地址排序。
- **位图**：使用位图来表示内存的使用状态，每个位对应一个固定大小的内存单元。

## 15.4 空间和时间效率的权衡

不同的空闲空间管理策略在时间和空间效率之间存在权衡：

1. **首次适应**：通常很快，因为不需要扫描整个列表。但可能导致在列表开始处堆积小的碎片。
2. **最佳适应**：可能产生更少的碎片，但需要扫描整个列表，所以较慢。
3. **分离列表**：减少搜索时间，但可能增加内存使用，因为需要维护多个列表。
4. **伙伴系统**：分配和释放相对较快（O(log n)），但可能导致内部碎片，因为块大小必须是2的幂次。

## 15.5 其他问题

### 15.5.1 外部碎片

即使总空闲空间足够满足请求，也可能因为空间被分割成许多小的、不连续的块而无法满足请求。这种情况被称为**外部碎片**。

处理外部碎片的技术包括：

- **压缩**（compaction）：移动所有已分配的块，使它们在内存中连续，从而留下一个大的空闲块。
- **使用分离列表或其他策略**来减少碎片。

### 15.5.2 内部碎片

**内部碎片**（internal fragmentation）发生在分配的块大于实际请求的大小时。例如，如果请求17字节，但分配器只能提供32字节的块（因为块大小必须是2的幂次），那么就有15字节的内部碎片。

### 15.5.3 物理内存管理

虽然我们主要讨论了虚拟内存管理，但操作系统还需要管理**物理内存**。物理内存管理通常更简单，因为：

- 不需要考虑页面替换（所有页面都在物理内存中）。
- 分配的单位通常是页面（如4KB），所以碎片较少。
- 可以使用简单的位图或链表技术。

## 15.6 总结

在本章中，我们探讨了操作系统如何管理空闲内存。我们讨论了基本的分割和合并操作，不同的空闲列表组织方式，以及各种策略之间的权衡。

关键的要点包括：

1. 空闲空间管理是一个经典问题，需要在时间效率（快速找到合适的块）和空间效率（减少碎片）之间取得平衡。
2. 不同的策略有不同的优缺点；最佳策略取决于具体的工作负载和系统要求。
3. 外部碎片和内部碎片是两个需要考虑的主要问题。
4. 实际系统通常使用组合策略，如分离空闲列表与伙伴系统相结合。

理解这些概念对于设计高效内存管理系统至关重要，无论是用于操作系统内核、用户级分配库，还是自定义的内存管理器。

## 15.7 问答题

1. **解释分割和合并**：在空闲空间管理的背景下，这两个操作的含义是什么？
2. **策略比较**：比较首次适应、最佳适应和最差适应策略。它们各自的优缺点是什么？
3. **外部碎片 vs 内部碎片**：这两者有什么区别？举例说明。
4. **伙伴系统**：解释伙伴系统的工作原理。它的主要优点和缺点是什么？
5. **分离列表**：什么是分离空闲列表？它如何提高性能？
6. **实际考虑**：在设计一个内存分配器时，需要考虑哪些实际因素？

## 15.8 编程作业

实现一个简单的内存分配器，支持：
- `malloc()`和`free()`函数
- 使用首次适应策略
- 实现分割和合并操作
- 处理外部碎片问题

测试你的分配器在各种工作负载下的性能，并与标准库的分配器进行比较。

---

*本章内容基于操作系统原理的经典概念，这些概念在现代内存管理系统中仍然具有重要应用价值。*